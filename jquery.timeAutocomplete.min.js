(function () {
  'use strict';

  /**
   * TimeFromToAutocomplete
   *
   * The from -> to autocomplete inputs (on absences dialog)
   */

  (function ($) {
    /**
     * TimeAutcomplete
     *
     * @constructor
     * @param {Object} opts An object of options to over-ride the defaults
     */
    var namespace = "timeAutocomplete";
    var time_data_prop = namespace + ".time";

    var TimeAutocomplete = function TimeAutocomplete() {
      this.initialize.apply(this, arguments);
    };

    TimeAutocomplete.prototype = {
      // Gets set in initialize
      el: null,

      // Instance of our formatter
      _formatter: null,

      _calling_from_init: false,

      // Default options
      default_opts: {
        auto_complete: {
          delay: 0,
          autoFocus: true,
          minLength: 0
        },
        auto_value: true,
        value: "",
        formatter: "ampm"
      },

      /**
       * Init called when we create a new instance
       * of this view. First param of 'options' passed in by backbonejs
       */
      initialize: function initialize($el, opts) {
        this.options = $.extend(true, {}, this.default_opts, opts);

        // Some global options (if set)
        if (typeof $.timeAutocompleteDefaults !== "undefined") {
          this.options = $.extend(true, {}, this.options, $.timeAutocompleteDefaults);
        }

        this.el = $el;
      },

      _callAutocomplete: function _callAutocomplete() {
        this.options.auto_complete.source = this._callFormatterMethod("filterSource", [this.el], function (req, responseFn) {
          throw new Error("You must set a hook_filterSource method in your formatter.");
        });

        // Make sure we have loaded the autocomplete plugin
        if (typeof $.fn.autocomplete === "undefined") {
          throw new Error("You need to include the jQuery UI bundle that has the Autocomplete plugin.");
        }

        // Call our autocomplete plugin
        this.el.autocomplete(this.options.auto_complete);
      },

      /**
       * When we click on the element and there are no
       * initial values in there, make some to show the user
       * they have to start typing a number
       */
      _bindEvents: function _bindEvents() {
        var self = this;
        var allow_focus = true; /* IE fix */

        $("body").on("click." + namespace, "ul.ui-autocomplete a", function () {
          allow_focus = false;
          setTimeout(function () {
            allow_focus = true;
          }, 100);
        });

        this.el.bind("keydown." + namespace, function (e) {
          self._keydownAutocomplete.apply(self, arguments);
        }).bind("keyup." + namespace, function (e) {
          self._keyupAutocomplete.apply(self, arguments);
        }).bind("blur." + namespace, function (e) {
          self._blurAutocomplete.apply(self, arguments);
        }).bind("focus." + namespace, function (e) {
          if (allow_focus) {
            self._focusAutocomplete.apply(self, arguments);
          }
        });

        if (this.options.auto_value) {
          this.el.trigger("blur." + namespace);
        }
      },

      _setupPlaceholder: function _setupPlaceholder() {
        if (typeof this.el.attr("placeholder") === "undefined") {
          this.el.attr("placeholder", this._callFormatterMethod("placeholderValue", [], ""));
        }
      },

      _focusAutocomplete: function _focusAutocomplete() {
        var val = $.trim(this.el.val()).substr(0, 2);
        if (this.el.data("uiAutocomplete")) {
          this.el.autocomplete("search", val);
        }
      },

      /**
       * Keydown autocomplete event
       *
       * @param {Object} e Event object
       * @param {HTMLElement} input The input we had the event performed on
       */
      _keydownAutocomplete: function _keydownAutocomplete(e) {
        var val = $.trim(this.el.val());

        // If they hit any of these keys DO NOT disable the auto complete, these
        // are acceptable key strokes.
        var ignore_keydowns = [8, // backspace
        9, // tab
        13, // enter key
        38, // up arrow key
        40 // down arrow key
        ];

        if (!~$.inArray(e.which, ignore_keydowns) && (e.which == 8 || val.length > 1 && !~val.indexOf("h") && !~val.indexOf(":") && $.isNumeric(val))) {
          try {
            this.el.autocomplete("close").autocomplete("disable");
          } catch (e) {}
        }
      },

      /**
       * Keyup autocomplete event
       *
       * @param {Object} e Event object
       * @param {HTMLElement} input The input we had the event performed on
       */
      _keyupAutocomplete: function _keyupAutocomplete(e) {
        if ($.trim(this.el.val()) == "" && this.el.data("uiAutocomplete")) {
          this.el.autocomplete("enable");
        }
      },

      /**
       * Blur autocomplete event
       *
       * @param {Object} e Event object
       * @param {HTMLElement} input The input we had the event performed on
       */
      _blurAutocomplete: function _blurAutocomplete(e) {
        var val = $.trim(this.el.val());
        val = this._callFormatterMethod("blur", [val], val);
        var new_value = "";

        if (val) {
          new_value = this._createStringFromFormat(this._readMind(val));
        } else {
          new_value = this._callFormatterMethod("blurEmpty", [val], val);
        }

        this.el.val(new_value);

        this._attacheUsableTimeData();
      },

      /**
       * Hit a formatter hook to get at the date value, then store it in a data
       * attribute for later if need be
       */
      _attacheUsableTimeData: function _attacheUsableTimeData() {
        var val = $.trim(this.el.val());
        this.el.data(time_data_prop, this._callFormatterMethod("getUsableTimeValue", [val]));
      },

      /**
       * Our 'ampm' formatter should be used by default. If we're adding a new
       * formatter, it will go into $.timeAutocomplete.formatters[formatter]
       *
       * @param {String} formatter The formater name we're setting to use.
       */
      setFormatter: function setFormatter(formatter) {
        this.options.formatter = formatter || this.options.formatter;

        if (!$.timeAutocomplete.formatters[this.options.formatter]) {
          throw new Error("Formatter: '" + formatter + "' was not found. Make sure you're loading it (formatters/" + this.options.formatter + ".js) after you load src/TimeAutocomplete.js");
        } else {
          this._formatter = new $.timeAutocomplete.formatters[this.options.formatter](this, this.options);

          if (!this._calling_from_init) {
            this._callAutocomplete();
          }

          this._calling_from_init = false;
        }
      },

      /**
       * Gets the formatter
       */
      getFormatter: function getFormatter() {
        return this._formatter;
      },

      /**
       * Gets the time in H:i:s format
       */
      getTime: function getTime() {
        return this.el.data(time_data_prop) || "";
      },

      /**
       * Call the formatter method (if it exists). If you look in formatters/ampm.js, all our hooks that
       * get called there are prefixed by "hook_".
       *
       * @param {String} method_name The method to call in the formatter file
       * @param {Array} args The arguments to pass to the formatter
       * @param {Array|Function|Object|String} default_val The default if the method_name does not exist in the formatter
       */
      _callFormatterMethod: function _callFormatterMethod(method_name, args, default_val) {
        var formatter = this.getFormatter();

        if ($.isFunction(formatter["hook_" + method_name])) {
          return formatter["hook_" + method_name].apply(formatter, args);
        }

        return default_val;
      },

      /**
       * The person typed something in that wasn't to our satisfaction.
       * Like '10' or '13' or '135' or '1350'
       *
       * @param {String} val The value from our input
       */
      _readMind: function _readMind(val) {
        return this._callFormatterMethod("readMind", [val], val);
      },

      /**
       * Combine formatted things
       *
       * @param {Object} obj The object containing h, m, sep etc.
       */
      _createStringFromFormat: function _createStringFromFormat(obj) {
        var combined = "" + obj.h + "" + obj.sep + ("" + obj.m + "");

        if (obj.postfix) {
          combined += obj.postfix;
        }

        return combined;
      },

      /**
       * Pass an H:i:s time format in as the value: '' attribute on the element or 'current'
       */
      _setValueAsTime: function _setValueAsTime() {
        var val = $.trim(this.el.val());
        var val_parts = val.split(":");

        if (val == "" && this.options.value) {
          this.setTime(this.options.value);
        } else if (val_parts.length == 3 && this.isNumber(val_parts[0]) && this.isNumber(val_parts[1]) && this.isNumber(val_parts[2])) {
          this.setTime(val);
        } else {
          var time = this._getCurrentTimeAsValue();
          this.el.val(time);
          this._attacheUsableTimeData();
        }
      },

      /**
       * Check if its a number
       *
       * @param {String|Int} n
       */
      isNumber: function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      },

      /**
       * Set the time by passing it a H:i:s format (13:30:00)
       *
       * @param {String} time 13:30:00
       */
      setTime: function setTime(time) {
        var stripped_time = time.replace(/[^0-9.]/g, "");
        var matched = stripped_time.match(/^[0-9]+$/);
        if (matched && matched.length && (matched[0].length == 5 || matched[0].length == 6)) {
          var val = this._callFormatterMethod("getTimeObjectFromHis", [time]);
          val = this._createStringFromFormat(val);
          this.el.val(val);
          this._attacheUsableTimeData();
        } else {
          throw new Error("Setting a time must be in H:i:s format. Example: 03:30:00");
        }
      },

      /**
       * Populate the input with the current time value
       */
      _getCurrentTimeAsValue: function _getCurrentTimeAsValue() {
        var formatter = this.getFormatter();
        var fake_date_data = [1987, 1, 17];
        var date = this._getCurrentDate();
        var current_h = date.getHours();
        var current_m = date.getMinutes();
        var current_time = new Date(fake_date_data[0], fake_date_data[1], fake_date_data[2], current_h, current_m).getTime();
        var bound_times = formatter.options.times.slice().concat(formatter.options.times);
        var entered_next_times = [];

        for (var i = 0, t = bound_times.length; i < t; i++) {
          var time = this._callFormatterMethod("getTime", [bound_times[i], fake_date_data]);
          var next_time = bound_times[i + 1] ? this._callFormatterMethod("getTime", [bound_times[i + 1], fake_date_data]) : false;
          var already_entered_next_times = !!($.inArray(next_time, entered_next_times) !== -1);
          entered_next_times.push(next_time);

          if (current_time > time && (next_time && current_time <= next_time || already_entered_next_times)) {
            return bound_times[i + 1];
          }
        }
      },

      /**
       * Get the current date
       */
      _getCurrentDate: function _getCurrentDate() {
        return new Date();
      },

      /**
       * Destroy the bound event to the element
       */
      destroy: function destroy() {
        this.el.removeData(namespace);
        this.el.removeData(time_data_prop);
        this.el.unbind("." + namespace);
        if (this.el.data("uiAutocomplete")) {
          this.el.autocomplete("destroy");
        }
      },

      /**
       * Render it out to the page
       */
      render: function render() {
        // Which formatter we're using.. 'ampm', 'french'?
        this._calling_from_init = true;
        this.setFormatter();
        this._callAutocomplete();

        if (this.options.auto_value) {
          this._setValueAsTime();
        }

        this._bindEvents();
        this._setupPlaceholder();

        return this;
      }
    };

    /**
     * Just slappin' on a global object to access some convenient formatters
     */
    $.timeAutocomplete = {
      formatters: {},
      _raw: TimeAutocomplete // exposed globally for the sake of testing it
    };

    /**
     * Wrap it all into a nice jQuery function
     *
     * @param {Object} opts The options passed to it when called (optional)
     */
    $.fn.timeAutocomplete = function (opts) {
      // Do the nasty on each one.
      return this.each(function () {
        var $el = $(this);

        // If it already exists, tear it down before setting a new one up
        if ($el.data(namespace)) {
          $el.data(namespace).destroy();
        }

        // Set up a new instance of the time autocomplete
        var ta_instance = new TimeAutocomplete($el, opts).render();
        $el.data(namespace, ta_instance);
      });
    };
  })(jQuery);

  (function ($) {
    $.timeAutocomplete.formatters["24hr"] = function () {
      this.initialize.apply(this, arguments);
    };

    $.timeAutocomplete.formatters["24hr"].prototype = {
      /**
       * The main instance that was created. Found on $('#el').data('timeAutocomplete')
       * of that specific element. Gets stuffed in on initialize();
       */
      main_instance: null,

      /**
       * These get merged in later. We take the default_opts and the formatter_opts from
       * initialize() and merge them into this options object.
       */
      options: {},

      /**
       * Some defaults to get over-ridden if needed. Can be done using
       * $('#el').timeAutocomplete({ formatter: '24hr' } });
       */
      default_opts: {
        increment: 15,
        start_hour: "00",
        hour_max: 24,
        blur_empty_populate: true,
        times: [],
        empty: {
          h: "12",
          m: "00",
          sep: ":",
          postfix: ""
        }
      },

      /**
       * Initialize the formatter
       *
       * @param {Object} main_instance Instance of timeAutocomplete on that element
       * @param {Object} formatter_opts Any options passed... $('#el').timeAutocomplete({ formatter: 'ampm', from_selector: ... });
       */
      initialize: function initialize(main_instance, formatter_opts) {
        this.main_instance = main_instance;
        this.options = $.extend(true, {}, this.default_opts, formatter_opts);
        this.generateTimes();
      },

      hook_placeholderValue: function hook_placeholderValue() {
        return this.main_instance._createStringFromFormat(this.options.empty);
      },

      /**
       * Get the timestamp on a time value
       *
       * @param {String} t The time (2:00 PM)
       * @param {Array} fake_date_data [1987, 1, 17]
       */
      hook_getTime: function hook_getTime(t, fake_date_data) {
        var time_parts = t.split(this.options.empty.sep);
        var h = time_parts[0];
        var m = time_parts[1];

        return new Date(fake_date_data[0], fake_date_data[1], fake_date_data[2], h, m).getTime();
      },

      /**
       * Get the H:is (13:30:00) time format and turn it into a time object
       * that we can pass back to the main view.
       *
       * @param {String} time_his 13:30:00
       */
      hook_getTimeObjectFromHis: function hook_getTimeObjectFromHis(time_his) {
        var time = time_his.split(":");
        var hour = time[0];
        var min = time[1];

        var time_obj = {
          h: hour,
          m: min,
          sep: this.options.empty.sep
        };

        return time_obj;
      },

      /**
       * Setup a filter when we type a key into this input.
       *
       * @param {Object} el The jQuery element
       */
      hook_filterSource: function hook_filterSource(el) {
        var self = this;
        el = el[0];

        return function (times, self) {
          return function (req, responseFn) {
            var self_val = $.trim(el.value);

            if (req.term.length == 1 && req.term.substr(0, 1) < 10) {
              req.term = "0" + req.term;
            }

            var re = $.ui.autocomplete.escapeRegex(req.term);

            var matcher = new RegExp("^" + re, "i");
            var a = [];

            if (self_val) {
              a = $.grep(times, function (item) {
                if (item.substr(0, 1) == 0 && item.length == 1) {
                  item = item.substr(1);
                }

                return matcher.test(item);
              });
            }

            responseFn(a);

            var val = self_val.toLowerCase();
            if (!a.length && val.length > 5) {
              // Should never be longer than 5 in french/24hr. Ie. 04h30 (5 characters), if it's longer, truncate it.
              self.main_instance.el.val(val.substr(0, 5));
            }
          };
        }(self.options.times, self);
      },

      /**
       * If we blurred and it was an empty value.
       */
      hook_blurEmpty: function hook_blurEmpty() {
        if (this.options.blur_empty_populate) {
          return this.main_instance._createStringFromFormat(this.options.empty);
        } else {
          return "";
        }
      },

      /**
       * Where our formatting actually happens.
       *
       * @param {String} val The value we're formatting
       */
      hook_readMind: function hook_readMind(val) {
        val = val.toLowerCase();

        return this.getTimeObject(val);
      },

      hook_getUsableTimeValue: function hook_getUsableTimeValue(val) {
        return val + ":00";
      },

      /**
       * Format our numbers.
       *
       * @param {String} original_val The original value
       */
      getTimeObject: function getTimeObject(original_val) {
        var h = "";
        var m = "";
        var new_num = "";

        if (~original_val.indexOf("h")) {
          var parts = original_val.split("h");
          h = parts[0] ? parts[0] : this.options.empty.h; // really? no hour. Must be jack-assery.
          m = parts[1] ? parts[1] : this.options.empty.m;
        } else {
          var numbers = original_val.replace(/[^\d]/g, "");
          numbers = numbers.split("");
          if (numbers.length == 4) {
            h = numbers[0] + numbers[1];
            m = numbers[2] + numbers[3];
          } else if (numbers.length == 3) {
            h = "0" + numbers[0];
            m = numbers[1] + numbers[2];
          } else if (numbers.length == 2) {
            h = numbers.join("");
            m = "00";
          } else if (numbers.length == 1) {
            h = numbers.join("");
            m = "00";
          }
        }

        // 91 entered.. format it to 09h10
        if (h > 24 && m == "00") {
          h = h.split("");
          m = h[1] + "0";
          h = "0" + h[0];
        }

        if (h.length == 1) {
          h = "0" + h;
        }

        if (m.length == 1) {
          m = m + "0";
        }

        if (!h && !m) {
          new_num = this.options.empty;
        } else {
          new_num = {
            h: h,
            m: m,
            sep: this.options.empty.sep
          };
        }

        return new_num;
      },

      /**
       * Generate an array of times to pass to our autocomplete source.
       * ['12h00', '12h15'] etc. Totally depends on the increment options set.
       */
      generateTimes: function generateTimes() {
        if (!this.options.times.length) {
          var start_minute = 60;
          var increment = this.options.increment;
          var date = new Date(2012, 1, 1, this.options.start_hour - 1, start_minute - increment);
          var arr = [];
          var hour_len = 60;
          var hours = this.options.hour_max;

          for (var i = 0, loop_int = hours * (hour_len / increment); i < loop_int; i++) {
            date.setMinutes(date.getMinutes() + increment);
            var h = date.getHours();
            var m = date.getMinutes();

            if (("" + h).length == 1) {
              h = "0" + h;
            }

            if (("" + m).length == 1) {
              m = "0" + m;
            }

            var label = h + this.options.empty.sep + m;
            arr.push(label);
          }

          this.options.times = arr;
        }
      }
    };
  })(jQuery);

  var defaultOptions = {
    from_selector: "",
    increment: 15,
    start_hour: 0,
    end_hour: 24,
    pm_text: "PM",
    am_text: "AM",
    blur_empty_populate: true,
    times: [], // over-ride if not using built-in populator
    empty: {
      h: "12",
      m: "00",
      sep: ":",
      postfix: " PM"
    }
  };

  var parse = function parse(time, format) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;

    var hour,
        minute,
        format = format || "H:i:s",
        pm = time.match(/p/i) !== null,
        am = time.match(/a/i) !== null,
        num = time.replace(/[^0-9]/g, "");

    // Parse for hour and minute
    switch (num.length) {
      case 4:
        hour = parseInt(num.charAt(0) + num.charAt(1), 10);
        minute = parseInt(num.charAt(2) + num.charAt(3), 10);
        break;
      case 3:
        hour = parseInt(num.charAt(0), 10);
        minute = parseInt(num.charAt(1) + num.charAt(2), 10);
        break;
      case 2:
      case 1:
        hour = parseInt(num.charAt(0) + (num.charAt(1) || ""), 10);
        minute = 0;
        break;
      default:
        return "";
    }

    // if 12 and am/pm not specified assume pm
    if (hour == 12 && pm === false && am === false) {
      hour = 12;
      pm = true;
    } else if (hour == 12 && pm === false) {
      hour = 0;
    } else if (pm === true && hour > 0 && hour < 12) {
      hour += 12;
    }

    // Keep within range
    if (hour <= 0) {
      hour = 0;
    }

    if (hour >= 24 && ("" + hour + "").length == 2) {
      var parts = ("" + hour + "").split("");
      hour = parseInt(parts[0], 10);
      minute = parseInt(parts[1], 10);
      if (minute < 6) {
        minute = minute + "0";
      }
    }

    if (minute < 0 || minute > 59) {
      minute = 0;
    }

    if (hour >= 13 && hour <= 23) {
      pm = true;
    }

    return format
    // 12 hour without leading 0
    .replace(/g/g, hour === 0 ? "12" : "g").replace(/g/g, hour > 12 ? hour - 12 : hour)
    // 12 hour with leading 0
    .replace(/h/g, hour.toString().length > 1 ? hour > 12 ? hour - 12 : hour : "0" + (hour > 12 ? hour - 12 : hour))
    // 24 hour with leading 0
    .replace(/H/g, hour.toString().length > 1 ? hour : "0" + hour)
    // minutes with leading zero
    .replace(/i/g, minute.toString().length > 1 ? minute : "0" + minute)
    // simulate seconds
    .replace(/s/g, "00")
    // lowercase am/pm
    .replace(/A/g, pm ? options.pm_text : options.am_text);
  };

  (function ($) {
    $.timeAutocomplete.formatters.ampm = function () {
      this.initialize.apply(this, arguments);
    };

    $.timeAutocomplete.formatters.ampm.prototype = {
      /**
       * The main instance that was created. Found on $('#el').data('timeAutocomplete')
       * of that specific element. Gets stuffed in on initialize();
       */
      main_instance: null,

      /**
       * These get merged in later. We take the default_opts and the formatter_opts from
       * initialize() and merge them into this options object.
       */
      options: {},

      /**
       * Some defaults to get over-ridden if needed. Can be done using
       * $('#el').timeAutocomplete({ formatter: 'ampm', from_selector: ... });
       */
      default_opts: {
        from_selector: "",
        increment: 15,
        start_hour: 0,
        end_hour: 24,
        pm_text: "PM",
        am_text: "AM",
        blur_empty_populate: true,
        times: [], // over-ride if not using built-in populator
        empty: {
          h: "12",
          m: "00",
          sep: ":",
          postfix: " PM"
        }
      },

      /**
       * Initialize the formatter. Called from within TimeAutocomplete file.
       *
       * @param {Object} main_instance Instance of timeAutocomplete on that element
       * @param {Object} formatter_opts Any options passed... $('#el').timeAutocomplete({ formatter: 'ampm', from_selector: ... });
       */
      initialize: function initialize(main_instance, formatter_opts) {
        this.main_instance = main_instance;
        this.options = $.extend(true, {}, this.default_opts, formatter_opts);
        this.generateTimes();
      },

      hook_placeholderValue: function hook_placeholderValue() {
        return this.main_instance._createStringFromFormat(this.options.empty);
      },

      /**
       * Setup a filter when we type a key into this input.
       *
       * @param {Object} el The jQuery element
       */
      hook_filterSource: function hook_filterSource(el) {
        var self = this;
        el = el[0];

        return function (times, self) {
          return function (req, responseFn) {
            var self_val = $.trim(el.value);
            var re = $.ui.autocomplete.escapeRegex(req.term);
            var has_am = ~re.toLowerCase().indexOf("a");
            var has_pm = ~re.toLowerCase().indexOf("p");
            var trim_ampm_possibilities = "";
            var is_one = !!(self_val == 1); // if they type "1", don't show "11" and "12".
            var do_has_am_pm_mind_read = (has_am || has_pm) && re.replace(/a|m|p/gi, "").length <= 2;

            if (do_has_am_pm_mind_read) {
              re = $.trim(re.replace(/a|m|p/gi, "")) + ":00 ";
              re += has_am ? self.options.am_text : self.options.pm_text;
            }

            // If the starting (from) time was 9:00 AM, and they start to type
            // 2 in the (to) spot, default to 2 PM because 2 is less than 9.
            // Only works on english.. not french.
            if (self.options.from_selector) {
              trim_ampm_possibilities = self.detectAMPMFromInstanceOverlap() == self.options.am_text ? self.options.pm_text : self.options.am_text;
            }

            var matcher = new RegExp("^" + re, "i");
            var a = [];

            if (self_val) {
              a = $.grep(times, function (item) {
                var return_nil =
                // If we want to trim out some AM/PM slots based on our mind reading
                trim_ampm_possibilities && new RegExp(trim_ampm_possibilities, "gi").test(item) ||
                // If we type in "1", don't show "11" and "12" possibilities
                is_one && item.substring(0, 2) != "1:" || ~self_val.toLowerCase().indexOf("p") && !~item.toLowerCase().indexOf("p") || ~self_val.toLowerCase().indexOf("a") && !~item.toLowerCase().indexOf("a");
                if (return_nil) {
                  return;
                }
                return matcher.test(item);
              });
            }

            responseFn(a);
          };
        }(self.options.times, self);
      },

      /**
       * When we blur on the input field. Make any corrections/modifications to the value
       *
       * @param {String} val The input value
       */
      hook_blur: function hook_blur(val) {
        // Clean up 03:00 am
        if (val.charAt(0) == 0) {
          val = val.substr(1);
        }

        return val;
      },

      /**
       * If we blurred and it was an empty value.
       */
      hook_blurEmpty: function hook_blurEmpty() {
        if (this.options.blur_empty_populate) {
          return this.main_instance._createStringFromFormat(this.options.empty);
        } else {
          return "";
        }
      },

      /**
       * Where our formatting actually happens.
       *
       * @param {String} val The value we're formatting
       */
      hook_readMind: function hook_readMind(val) {
        var am_pm = "";

        val = val.toLowerCase();
        if (this.options.from_selector && !~val.indexOf("a") && !~val.indexOf("p")) {
          am_pm = this.detectAMPMFromInstanceOverlap();
        }

        return this.getTimeObject(val, am_pm);
      },

      /**
       * Convert an '1:00 PM' to H:i:s so it's usable for storing in the DB.
       *
       * @param {String} val
       */
      hook_getUsableTimeValue: function hook_getUsableTimeValue(val) {
        return this.parseTime(val);
      },

      /**
       * Get the timestamp on a time value
       *
       * @param {String} t The time (2:00 PM)
       * @param {Array} fake_date_data [1987, 1, 17]
       */
      hook_getTime: function hook_getTime(t, fake_date_data) {
        var time_parts = this.parseTime(t).split(this.options.empty.sep);
        var h = time_parts[0];
        var m = time_parts[1];

        return new Date(fake_date_data[0], fake_date_data[1], fake_date_data[2], h, m).getTime();
      },

      /**
       * Get the H:is (13:30:00) time format and turn it into a time object
       * that we can pass back to the main view.
       *
       * @param {String} time_his 13:30:00
       */
      hook_getTimeObjectFromHis: function hook_getTimeObjectFromHis(time_his) {
        var time = time_his.split(":");
        var hour = time[0];
        var min = time[1];
        var ampm = hour >= 12 ? this.options.pm_text : this.options.am_text;

        if (hour.length == 2 && parseInt(hour, 10) < 10) {
          hour = hour.substr(1);
        }

        if (hour > 12) {
          hour -= 12;
        }

        if (hour == 0) {
          hour = 12;
        }

        var time_obj = {
          h: parseInt(hour, 10),
          m: min,
          sep: this.options.empty.sep,
          postfix: " " + ampm
        };

        return time_obj;
      },

      /**
       * If we have a $(self.options.from_selector), then we type '2' into the To field,
       * we should look at the From field to determine whether or not to make it 2pm
       * or 2am. Do awesome stuff to figure it out.
       */
      detectAMPMFromInstanceOverlap: function detectAMPMFromInstanceOverlap() {
        var trim_ampm_possibilities = "";
        var from_obj = this.getTimeObject($(this.options.from_selector).val());
        var to_obj = this.getTimeObject($.trim(this.main_instance.el.val()));

        if (from_obj.postfix && (~from_obj.postfix.toLowerCase().indexOf("a") || ~from_obj.postfix.toLowerCase().indexOf("p"))) {
          var from_ampm = ~from_obj.postfix.toLowerCase().indexOf("a") ? this.options.am_text : this.options.pm_text;
          var to_hour = to_obj.h;
          var from_hour = from_obj.h;

          // If it's 11:00 PM - 12.. it should say 12 AM and not PM.
          if (from_hour == 12 && to_hour != 12) {
            trim_ampm_possibilities = from_ampm == this.options.am_text ? this.options.am_text : this.options.pm_text;
          } else if (to_hour == 12 && from_hour != 12) {
            trim_ampm_possibilities = from_ampm == this.options.am_text ? this.options.pm_text : this.options.am_text;
          }
          // 10:00 AM > 2:00 PM, 10:00 PM > 2:00 AM
          else if (from_hour > to_hour) {
              trim_ampm_possibilities = from_ampm == this.options.am_text ? this.options.pm_text : this.options.am_text;
            }
            // 10:00 AM < 11:00 AM, 5:00 PM < 7:00 PM
            else {
                trim_ampm_possibilities = from_ampm == this.options.am_text ? this.options.am_text : this.options.pm_text;
              }
        }

        return trim_ampm_possibilities;
      },

      /**
       * Format what we've got into an english readable format.
       * So turn '1030' into '10:30 am' etc.
       *
       * @param {String} original_val The original value to format
       * @param {String} am_pm Whether or not it's 'am' or 'pm'
       */
      getTimeObject: function getTimeObject(original_val, am_pm) {
        var t = this.parseTime(original_val, "g:i:A").split(":");
        var h = t[0];
        var m = t[1];
        var new_num;

        if (!h && !m) {
          new_num = this.options.empty;
        } else {
          new_num = {
            h: h,
            m: m,
            sep: ":",
            postfix: " " + (am_pm ? am_pm : t[2])
          };
        }

        return new_num;
      },

      /**
       * Generate an array of times to pass to our autocomplete source.
       * ['12:00 AM', '12:15 AM'] etc. Totally depends on the start_hour and increment options set.
       */
      generateTimes: function generateTimes() {
        if (!this.options.times.length) {
          var start_minute = 60;
          var increment = this.options.increment;
          var date = new Date(2012, 1, 1, this.options.start_hour - 1, start_minute - increment);
          var arr = [];
          var hour_len = 60;
          var hours = this.options.end_hour;
          var hour_looper = hours - this.options.start_hour;
          var pop_last = false;

          if (hour_looper == 24) {
            pop_last = true;
          }

          for (var i = 0, loop_int = hour_looper * (hour_len / increment); i <= loop_int; i++) {
            date.setMinutes(date.getMinutes() + increment);
            var h = date.getHours();
            var m = date.getMinutes();
            var ampm = h > 11 ? this.options.pm_text : this.options.am_text;

            if (h == 0) {
              h = 12;
            }

            if (h > 12) {
              h = h - 12;
            }

            if (("" + m).length == 1) {
              m = "0" + m;
            }

            var label = h + ":" + m + " " + ampm;
            arr.push(label);
          }

          if (pop_last) {
            arr.pop();
          }

          this.options.times = arr;
        }
      },

      parseTime: function parseTime(time, format) {
        return parse(time, format, this.options);
      }
    };
  })(jQuery);

  (function ($) {
    $.timeAutocomplete.formatters.french = function () {
      this.initialize.apply(this, arguments);
    };

    $.timeAutocomplete.formatters.french.prototype = $.extend(true, {}, $.timeAutocomplete.formatters["24hr"].prototype, {
      default_opts: {
        empty: {
          sep: "h"
        }
      },

      hook_getUsableTimeValue: function hook_getUsableTimeValue(val) {
        return val.replace(this.options.empty.sep, ":") + ":00";
      }
    });
  })(jQuery);

}());
